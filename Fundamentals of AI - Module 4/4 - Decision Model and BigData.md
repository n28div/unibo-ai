# Decision Model and Notation

[Recording](https://web.microsoftstream.com/video/b3d6ede0-9467-4e55-b7c2-e063d7aa662c)

A decision can be modeled as an iterative process. We describe the decision, its requirements, its identification...

Problem is that in 2016 the object modeling group came out with a standard *The Standard Decision Model and Notation* and there are a huge number of firms supporting it.

# Big data challenges

We have a shitton of data. **Complex Event Processing** is a paradigm that deals with that. For example, in Bologna there's sensors under the streets that feel cars passing by. We'd like to extract some knowledge from these events. We now have a now dimension: the *temporal dimension*! Up to now, we've always skipped this! We have simple events from which we can obtain complex events: these are generated by the system itself, by aggregating the simpler ones.
The simple events are a paradigm to understand the signals that the system receives. Note that simple and complex do not refer to the information payload, rather to what are called the *business questions*: complex events are the ones providing an answer to these questions. The idea of a complex event processing is a module named *Complex Event Recognition Module*, we want something that taken the definition of complex events and the simple events, outputs complex events.
How are these related with rules? We can somehow get an intuition: the languages that recognize complex events are usually based on rules!

A number of different approaches were introduced to solve this: automata-based, tree-based, logic-based... A solution is Drools support to these (no EC), or EC by Kowalsky which has limits: to solve this, Drools+EC.

## CEP and Drools

Drools provides a support for CEPs: *Drools Fusion*.

This is linked to the *frame problem*.

Here, events (i.e. happening of something) are considered as particular facts, having a timestamp. What is interesting is that it already supports the **Allen algebra**, i.e. 

On the base of rules, Drools is able to automatically decide when it is possible to discard events, for example *I'm receiving thousands of events, I put them all in the memory, cluttering it. Do I really need these? The more time passes, the less available space I'll have.* Otherwise, we won't be able to reason. When used properly, Drools Fusion is able to discard events autonomously. In order to get such a behavior, the user should avoid rules that would imply to connect events too far in the time line. It's therefore partly up to us in the writing of rules.
It supports aggregation operators and sliding windows. The assumptions that are made on the basis of CEP in Drools, are that first of all we usually require lots of events, of which only a small percentage are of interest (because we'd like to discard not-needed events).
Events are usually immutable: they are objects (instances of classes in Java), but they are **immutable**. The rules and the queries must run in reactive models: we'd like to react to event, as soon as it happens, i.e. we are in an active world. Another assumption is that it is quite interesting to connect events by means of temporal relationships: this is not the only possible way, but the idea is that we're probably interested in that. 

We aren't interested in the cloud mode anymore, but in the *Stream mode*, i.e. *every event has a timestamp and **there is a clock**.* Why is it important to have a clock? From it, we'll derive the notion of **now**. Without a clock we cannot have it. The idea is that an event's timestamp is in some way linked to this clock's timestamp. This can be based on the timestamps of events, on an internal clock, on an external source (like *tick events*)...

### Sliding windows

As soon as we understand that we can relate events with respect to their time of happening, we would like to express things like *the events on the last 2 hours*, or *the last 100 events*. These are related to the concept of **sliding windows**, i.e. things that restrict/focus on the events of interest. It is constantly moving when time passes, and the idea is that we can answer to two different concepts: time-based windows and length-based ones. 

There are two ways to *expire* events: explicit and implicit expiration. The first one is the default mechanism to guarantee that our mechanism is not killed, while the second one is a performance improvement.

Allen's logic is a logic about **intervals**: the idea is that the msot general possible operator of the `after` operator is that the difference between the starts of two events should be between an interval. There are some operators defined by Allen, like `before`, `meets`, `met-by`, `overlaps`...

### State

[Recording](https://web.microsoftstream.com/video/8a5c5b7e-f1a3-440b-a73a-04daa268d4d1)

Rules that can keep some sort of *state*, like *if something happened in the last 10 minutes* can't really exists. Real systems, though, can usually represent the notion of state. How do we do this in Drools? The solution was proposed in 1986 in a famous paper, *Even Calculus Framework* (a good similar paper is by Shanamanah), which was kind of complex. The notion of *fluents*, i.e. properties for which the truthness value is able to change over time, is used for this. The system is described by a **complete set of fluents**. Another characteristic that is nice about this is that of meta-events: the fact that the state is changing is an event itself. We have some predicates that allow us to express fluents, like `HoldsAt` or `Happens`.

## Event Calculus

Event Calculus in Prolog is not safe. There were a couple of solutions to overcome the deductive nature of the original formulation. Though, the computational cost is so high that when you're dealing with lots of events, it isn't sustainable.

# Reactive event calculus and Drools

We have a scenario with a set of data which is continuously collected (on-site, possibly) and elaborated.

We are therefore receiving a stream of events, which we'll have to deal with it with runtime performances (i.e. fast).
The PROLOG implementations are not suitable for this use case. First of all, we'll always have to separate clearly what events are from state properties (do we need those?).
This is something that is related to understanding the domain, needing a domain expert. This is not an easy task actually.

A classical problem is that domain experts usually describe the terms of the system in terms of events themselves. A fluent might be affected by several events: think about a room and a light on its roof, we can have a simple situation with one switch, or a more complex one with multiple switches. 

We'll then define the rule, and instead of raising up a fluent as a consequence, we implement one additional layer: the idea is *for any of these events, define the rule and the consequence will be a special UpEvent, one for each fluent.* These rules can now combine a number of conditions. 

This allows us to perform **meta-reasoning**. When possible, we'll want to remove rules: drools has a great support for events, and there's some reasoning that we'll need: while events are automatically discarded, fluents are not!









